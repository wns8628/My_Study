인덱스

기본용어 

 - 데이터베이스 

  데이터파일과 로그파일로 구성 
  데이터파일 : mdf, ndf 
  로그파일 : idf확장자 
  다양한 형태의 개체들을 포함 : 테이블, 익덱스,뷰,함수,트리거,프로시저 등등 

  		*테이블 : 우리의 데이터를가지고 물리적으로 저장되있다.

 
 
 쿼리문때리면(select) : 테이블로날라감 ? - 아님  인덱스로날라가게해야함

 페이지: 테이블에 데이터를 insert하게되면 그 행 ,그 레코드는 (8kb)페이지에
            들어오게됨 (쓰여짐)

           근데 페이지하나당 데이터가 10개있으면  100개읽으려면 페이지 10개읽어야함..
         
           이것이성능의 시작이다. --페이지를 잘 알아야한다. 

          즉 페이지내의 행이 많을수록 i/o효율증가

         0번부터 n사이의 순차적인 번호 페이지번호가있다.             

         
             
        
         100

 12    홍길동   ---  100번 페이지에 4개의 행이 포함되어있다.   한번읽을떄 4개읽는다.
 14    안경태   ---
 28    김치국   --- 
 27    오발탄   ---


---------------------
 - 인덱스는 주민센터(사람찾기), 도서검색시스템, 다리(강건너그곳에 가장빨리갈수있게)

 = 빨리빨리 

 인덱스의 장점 : 빠른데이터검색 

  - 찾는데이터를 가지고있다면 직접주거나 ,없다면 어디있는지 알려줌 

  - 데이터 중복방지 : pk , 유니크 제약 

  - 잠금 최소화 - 최소범위 잠금가능 , 동시성높여줌
                     = 즉 그부분만빨리 업데이트하고나오기때문에 동시성높여줌

  
  단점 

     -  물리적인공간차지 (테이블,인덱스 두개밖엥벗다 물리적으로저장되는건)
     -  인덱스는 테이블처럼 데이터를 가짐 -즉 페이지가있다
 
     - select는 인덱스좋아함 , insert문은 인덱스를 별로좋아하지않는다(전입신고해야함)
          
     
----------------------------------

 유지관리필요성

  - 인덱스는 전지전능x 

  - 인덱스 조각화문제(내부,외부) , 자동화? 
                                
 ------------------------------------------------------

 테이블의 존재형태 

  힙 형태이던지,  클러스터형 인덱스 형태이던지 	
		(정렬되있다)
                 <바꾸기> 


   비클러스터형 인덱스들의 도움을 필요로한다 = 정렬되있다.  이걸 추가하는거임 

 
 * 인덱스는 정렬되있는 데이터를 가지고있기때문에 빠르다





 ---
 힙 =  정렬되어 저장되지않은 테이블의 존재형태  - 행들간순서가없다
                                                                - 데이터 페이지들 간에도 순서없다.
                                                                *클러스터형 인덱스가 없는테이블이다

 즉 insert는 좋아함 빈공간에 다집어넣으면되니깐
    select는 싫어함 찾기힘드니깐 
-

클러스터형 인덱스  = 정렬되있다, 데이터를 가지고있다 = 강력
 
  이메일로정렬하고싶다 이메일 빼서 클러스터형걸어버리면된다????

   힙->클러스터형 = 힙은사라지고 다른곳에 클러스터형 인덱스가 생성됨 

      만들때 유니크속성 왠만하면줘라..

   
  만능이아니다 - a를기준으로 정렬되있지만 a=5인것 = 빠르지만
 
                                                          b=10 .. 이건어캐찾냐 시간오래걸린다  




    * 그래서 힙이든 클러스터형이든 = 비 클러스터형 인덱스가 필요하다. *


 
- Table scan -------------------------------------------------------

  데이터를 찾을수있는 유일한 방법
 
  모든페이지 다읽어야함, 참고:iam페이지를 참조해서 해당 데이터를 모두 읽게 됨 





---------------------------------------

 힙
 +
 비클러스터 형 인덱스 ( 데이터 + RID )
 
          예를들면 이메일데이터를 다들고있고 또 RID: 행의주소를가지고있다 .	
					  (몇번째줄,몇번째행 이런거)	
   					
         이메일다들고있는데 다른거요구하면 RID를통해서 찾아가라하는거지
 			
 
 데이터찾아가는거 = index Seek = 루트페이지부터 찾아가기  
   
                       
   클러스티드 인덱스 시크 = 앞에 없거나 클러스티드빠지면 다 non클러스티드임 

 
  RID Lookup = 찾아가는데 힙 에찾아가는거임(힙의 형태로 테이블을가지고잇다 ) 
 
  인덱스스캔 - 리프수준의 모든인덱스 페이지를 쫘악 읽음 
                    이테이블의 레코드총개수?구할때 = 이게더빨라서
   


  -----------------------------------

 클러스터 형 인덱스  (이미정렬되어있다.)
 +  
 비클러스터 형 인덱스 ( 데이터 + 클러스터 형 키열? ) 

 
---

힙 + 넌클 =  인덱스 키값 + RID ,

클러스터+넌클 = 인덱스 키값 + 클러스터형 인덱스 키값 


-------------------------------------
알품인

 즉 힙의 A열에 인덱스걸면 

 넌클러인덱스에는 A열의 모든데이터와 RID가걸린다


-----------------------
키품인

 클러스터형인덱스(c에 클러스터가걸려잇다, c로정렬되어있다.)의
  A열에 인덱스를걸면(A에다 넌클러스트를만든다) 

 넌클러 인덱스는 A,C 가 들어간다  
  
 
커버드 쿼리 = 데이터까지안가고 데이터 찾아옴


--

걸수있는거?  15개 900kb?   
 
 많이걸면 테이블과 다를게없잔아.. 욕심내지마 

------------
 

 1. Non-clustered Index : 인덱스의 데이터가 테이블의 데이터 영역과 구별된 독립적인 영역에 존재하는 인덱스.

넌클러스터드 인덱스는 우리가 흔히 알고있는 인덱스의 구조를 갖는다.

인덱스는 아래 그림과 같이 Root, Intermediate, Leaf의 세 영역으로 구분되는 구조를 갖는데,

Root부터 Leaf 레벨까지 모든 인덱스데이터가 데이터 영역이 아닌 별도의 영역에 만들어지게 된다.

즉, 테이블 데이터가 직접 정렬되는 것이 아니고 별도의 데이터가 생성되어 정렬되는 것이므로 넌클러스터드 인덱스는 복수로 생성이 가능하다.


 


