반복문 

제어- break
 for(var i =0; i<10; i++){
 if(i==5){
   break;
  }
 document.write('코딩에브리바디'+i+'<br />');
 }

 5일떄 반복문끝 

   if(i==5){
      continue;
   }

 그 순간에만 종료(반복문은 계속됨)

 

 반복문의 중첩
 
 0부터 100까지 출력하는데 

 0,1,2 가아니라 
 
 00, 01, 02 ... 99 이렇게 할려고한다 

 
 for(var i=0 ; i<10; i++){
   for(var j=0; j<10; j++){
	document.write(i+j);	= 숫자+숫자 가되서 망함 그래서 String(i) +  String(j) 해야함 
    } 
  }

 근데 앞에 문자열이있으면 자바스크립트는 문자로 자동변환해서 해줌!


 크롬개발자도구 디버거 

 소스탭가서 클릭해서 브레이크포인트걸고 
 
 f5로 리로드 해서 제어하면됨


반복문은 배열과사용되면 진면목을 볼수있다!!


함수 -------------------------------------

 
 하나의 로직을 재실행할수있도록 하는것

 function 함수명 ([인자..[,인자]] ){ 
   코드
  }

 이런 형태임

 이렇게 함수를 정의하면 
 쓸떄는 호출해서 쓰면된다; 

 함수명(); 이렇게






-----------------

 배열 


 데이터를 담는 그릇 


  [] <= 이걸씀 

 var member = ['a','b','c'];
 
   member[0] = a		인덱스, 색인

 겠지

 
- 배열왜씀? 
 
  함수는 여러인자를 받지만 반환할떄(리턴)는 1개만 반환한다.= 한계

 이한계를 극복 = 배열이다.

function get_members(){
    return ['egoing', 'k8805', 'sorialgi'];
}

var members = get_members();

document.write(members[0]);
document.write(members[1]);
document.write(members[2]);

굿?

배열은 반복문과 만났을떄 진정한힘을발휘한다. 

문자열에 toUpperCase(); 이걸쓰면 대문자로 바꿔줌

	메소드?

 문자열에 .length 메소드쓰면 배열길이알려줌
		
 ()이게없으니 변수겟지?)

for(i = 0; i < members.length; i++){
    document.write(members[i].toUpperCase());   
    document.write('<br />');
}

 이런식으로하면된다. 

 
배열을 제어하는방법 -- 

 배열에 하나의 원소를 추가      - 배열.push(넣을원소);
  
 배열에 여러개의 원소를 추가    - 배열.concat(['f','g']);

 이것들은 배열꼬리에다가 추가함

 배열맨앞에 추가함              - 배열.unshift('z');

 중간어디가에다가 추가함        - 배열.splice(인덱스,0,넣을원소,넣을원소2.., 3..);
						     1 (삭제하고 그위치에다가 순서대로넣음)


 배열의 제거                    - 배열.shift();   = 젤앞의 인덱스의 원소를 제거함 
                                - 배열.pop();     = 맨뒤의 인덱스의 원소를 제거함 
 
 
 배열의 정렬                    - 배열.sort();    = 순서대로 정렬 
                                - 배열.reverse(); = 역순으로 정렬


   어떠한 기준으로 정렬을하고싶다. (사전찾아봐서 해라)


 
 
 				
------------객체	

 배열과 유사하다 = 연관된 데이터를 담는 그릇!

 배열은  a b c 
 인덱스  0 1 2 
 
 
 객체는 a b c 
 인덱스 f s t     
 
 즉 인덱스를 직접다르게 지정가능 ! 

 연관배열 , 맵 , 딕셔너리 라는 데이터타입이 객체에 해당. 

 
 객체를 만드는 방법
 
  var grades = {'a':10,'b':6,'c': 80}

        인덱스 : a, b, c 임





 	    
 -----------------------
 

 모듈 (부품)

 재활용성, 유지보수를위해 다양한기법사용 

  
 함수를모으거나,변수를 모와서파일로 쪼개다음에 

 그파일을 읽어오는방법을 통해 마치 함수처럼 

 재사용성을 높힌다. 


-자주 사용되는 코드를 별도의 파일로 만들어서 필요할 때마다 재활용할 수 있다.
-코드를 개선하면 이를 사용하고 있는 모든 애플리케이션의 동작이 개선된다.
-코드 수정 시에 필요한 로직을 빠르게 찾을 수 있다.
-필요한 로직만을 로드해서 메모리의 낭비를 줄일 수 있다.
-한번 다운로드된 모듈은 웹브라우저에 의해서 저장되기 때문에 동일한 로직을 로드 할 때 시간과 네트워크 트래픽을 절약 할 수 있다. (브라우저에서만 해당)

 
 그니깐 스크립트(js) 파일을 따로뺴서 
 링크만 불러와서 쓰면되겠지
 
 ==========================================
 script src="파일명.js" 이렇게 링크화시켜옴  js파일이 모듈인 것이다 .
 ==========================================

 모듈화의 중요성 이제 알겠지?

 노드js에서는 모듈을 불러오는게 require 이거임 알지? 


-라이브러리
 
 모듈과비슷하다 

 모듈       - 부품적인느낌
 
 라이브러리 - 자주사용하는걸 재사용하기 편리하도록하게한 코드들의 집합?

 jQuery < 이 라이브러리를 쓰면 한줄로끝낼수있는걸 브라우저만의 기능으로하면 만줄이될수있다.

  
 제이쿼리로드해서(알아서할줄알제)

 <script> 

  $('#list li').text('coding everybody');  뭐 이런식으로 함
 
</script>


  $('#execute_btn').click(function(){
      $('#list li').text('세준');
    })
 
 뭐 이렇게 .. ok?  이걸 그냥 짤려고한다면 20줄이상 존나헷갈린 기능으로 해야함





  ============================================


     값으로서의 함수와 콜백 


- 자바스크립트에서는 함수도 객체다.

    함수 = 값 (자바스크립트만의 그것)

    변수 = 값을 넣을수있다.


 
  function a() {}
			 둘다같다. 
  var a = function(){}


 즉 함수도 객체안에 저장될수있다. 

===========
 객체안에정의된 함수 = 메소드  

  a = {    b: function(){}     }
         속성    메소드 
=========== 

 first-class citizen  = 다양한형태로 사용되는 값
             object    

  함수는 값이기 떄문에 인자로도 전달가능 (매개변수)

 
  함수는 함수의 리턴 값으로도 사용할 수 있다. 
  		  return func[mode];

  배열값으로도 사용가능  

	var process = [
    		function(input){ return input + 10;},
    		function(input){ return input * input;},
   		function(input){ return input / 2;}
		];


 
------

  콜백 

   var numbers = [20, 10, 9,8,7,6,5,4,3,2,1]; 

   function sortNumber(a,b){
    return b-a;				<- 콜백함수 
   } 

   alert(numbers.sort(sortNumber)); // array, [20,10,9,8,7,6,5,4,3,2,1]
			콜백

  즉 콜백함수를 인자로 전달받아서 내부적으로 호출하는걸 통해서 

     기본적인 동작방법을 바꿀수있다.
     
   
 
   콜백이 가능한이유 = 함수가 값이기떄문에

 
 -- 

 비동기 처리 

   콜백은 비동기처리에서 유용하게 사용

   	동기적처리  글작성 -> 이메일발송(3시간) -> 작성완료
	
      비동기적처리  글작성 -> 이메일발송(예약)  -> 작성완료 				
	 (백그라운드에서 예약이들어왔는지 확인하고 있으면 뒤에서 보냄)

    

  자바스크립트( Ajax 에서 비동기 쓸수있다.)
 
         asynchronous - 비동기          
         javascript   
         and  
         XML         
  
     이거 꼭배워야됨 왜냐 

       웹페이지를 전체를 리로드안하고 내정보 같은걸 누르거나 그러면 조그만한창
       이런거 

       조용히 서버랑 통신 하는것 말한다. 

   이게 만약 동기라면 내 정보를 누르는 순간 웹페이지 전체가 멈추게된다.(기다려야하니)

==

   $.get('./datasource.json.js', function(result){
        console.log(result);
    }, 'json');
 
  서버에서 정보를 가져오는 행위는 똑같음 $.get 이런거 
  똑같은 부분은 알아서처리하고 

  그정보를 가지고와서 무슨일을 할건지는 다르잔아 
  비즈니스로직은 똑같지 않기때문에 사용자에게 위임해서 

  콜백함수를 통해서 인자를 전달받아서 그걸로  

  함수를 매개변수로 전달하는것으로 통해서 

  $.get 이 동작하는 방법을 완전히 바꿔놓을수 있는것이다. 

   
  
    
 
   
     
 
 --------------------------

 클로저 

 내부함수가 외부함수의 맥락(context)에 접근할 수 있는 것을 가르킨다.


 한함수 안에서만 사용되는함수면 응집성,보기도편해,무언가 방해할것도 없다.
 그래서 이걸쓴다.


 

 function outter(){
    function inner(){
        var title = 'coding everybody'; 
        alert(title);
    }
    inner();
}
outter();

 
  이것과 같이 내부함수에서 외부함수의 지역변수에 접근 할 수 있다.  

외부함수의 실행이 끝나서 외부함수가 소멸된 이후에도 
내부함수가 외부함수의 변수에 접근 할 수 있다.
 이러한 메커니즘을 클로저라고 한다.


 function outter(){
     var title = 'coding everybody';  
     return function(){        
         alert(title);
     }
  }
 inner = outter();     <<이렇게 하면 리턴된값(함수) 가 들어가겠지 
 inner();


 리턴되었다= 생을마감했다.

  그런데도 title이라는 것을 내부함수가 사용을 할 수 있다.! 



function factory_movie(title){
    return {                        << 객체를 리턴= 생을마감=타이틀에 직접접근 불가
        get_title : function (){
            return title;
        },
        set_title : function(_title){
            title = _title
        }
    }
}

 즉 프라이빗변수를 쓰게하는 아주좋은 메카니즘이다

 JavaScript는 기본적으로 Private한 속성을 지원하지 않는데,
 클로저의 이러한 특성을 이용해서
 Private한 속성을 사용할 수 있게된다. 

 

 자바스크립트에서는 오로지 함수의 괄호 안에서만 
 지역변수로서 할당되고  
 그 외 모든 장소는 전역변수로 취급을 받습니다.


//기존의 코드
var Sample = function(...){...} // 함수 자체를 변수에 담는다.

//수정된 코드
var Sample = function(...){....}(); // 함수를 호출하고 반환되는 값을 변수에 담는다.[출처] Javascript - Closure(클로저)|작성자 군옥수수


 이걸잘 기억해라! 배열에 함수자체가 담기면 55555 이렇게 출력된다! 

  이걸 내부함수로 만들고 바로 호출해야됨 








-----------------------------------

 프로토타입 기반 프로그래밍 - 자바스크립트

 자바스크립트 객체는 좀 다를거다.. 


 객체지향 간단히 - 연관된 변수 
                   연관된 메소드   -> 객체그릇에 넣은 것

 		   연관안된 변수,메소드는 또다른 객체에 넣는다.


 var person1 = {
    'name' : 'egoing',
    'introduce' : function(){
        return 'My name is '+this.name;
    }
}
document.write(person.introduce());

var person2 = {
    'name' : 'kim',
    'introduce' : function(){
        return 'My name is '+this.name;
    }
}
document.write(person.introduce());


 객체가 2개지만 메소드가 완전히 중복된다. 즉 바꿀때 하나씩다

 바꾸어주어야한다 = 중복! 이걸 방지하기위해 생성자 즉 new를 배워보자 


* 자바스크립트는 객체이자 함수!이다 기억해라 함수!
                               

 생성자(constructor) 객체를 만드는 역할을 하는 함수다.


  
function Person(){}  

 이렇게 정의하고 

 var p = Person(); 을 하면 언디파인 뜨지 왜 ? 호출했는데 암것도 없으니 

 var p1 = new Person(); 을하면! 새로운객체를만든후 리턴한다 (생성자)
 

  자바 = 클래스안에 생성자가있고 그걸통해서 객체(인스턴스를생성)생성
 
  자바스크립트 = 생성자가 어디에 소속되어있지않고 그냥 함수다 그 함수에 new를 붙이면 객체를생성


  즉 함수에 new를 붙여서 호출하면 리턴값은 "객체"가 된다. 


  왜쓰냐? = 초기화를위해 (init) 

 ex)
   var p1 = new Person('egoing'); 즉 이렇게 생성자를 통해 초기화를하면 

                                  이고잉이 들어간 프로퍼티를 가진 객체를생성 

                                  어떠한메소드를 가져야하는지 셋팅해주는것
 
-------------------------------

 전역객체 

 전역객체(Global object)는 특수한 객체다. 모든 객체는 이 전역객체의 프로퍼티다.
 

 function func(){
    alert('Hello?');    
  }

 func();	= 이렇게호출 (일반적)
 window.func(); = 원래 윈도우객체의 프로퍼티인것이다.


 var o = {'func':function(){
     alert('Hello?');
  }}

 o.func();
 window.o.func();  = 즉 원래 이렇게 인 것이다. 


 웹브라우저는 window가 전역객체 
 node.js는 global 이 전역객체 
 
 즉 전역객체 API 를 쓸수있다. 


-----------------------------------------------


  this  

 this는 함수 내에서 함수 호출 맥락(context)를 의미한다. (사용에따라 의미가 달라질수있다)


 함수 안에서 사용되는 키워드다
 
 변수,약속된 변수, 함수를어떻게 호출했느냐에따라 달라짐 


  --this는 전역객체인 window와 같다.

 다른 방법으로 호출했을떄 this가 어떻게 바뀌는지 보자

  
   * 객체의 소속인 메소드의 this는 그 객체를 가르킨다. 
  
 

 즉 

  func(); 이렇게해서 this는 

 window를 말하지 

 window.func(); 

 즉 펑크라는하는 함수는 윈도우안의 메소드이기떄문에 이렇게되는거지 

  o.func(); 는 o가 디스지 같은 의미이다.

 소속된것을 잘생각해보면 된다.


--생성자에서의 this 

 함수를 호출했을 때와			- this는 윈도우겠지  

 new를 이용해서 생성자를 호출했을 때의 차이를 보여준다. - this는 그 속한객체랑같겟지


생성자는 빈 객체를 만든다. 그리고 이 객체내에서 this는 만들어진 객체를 가르킨다. 이것은 매우 중요한 사실이다. 생성자가 실행되기 전까지는 객체는 변수에도 할당될 수 없기 때문에
 this가 아니면 객체에 대한 어떠한 작업을 할 수 없기 때문이다. 



 자바스크립트 함수는 자바와달리 위상이높다 ㅋㅋ 노예가아니다

 어디든지 소속될수있다.!  

 즉 함수는 누구의 소속인가? 이것만 알면 this가 뭔지 알아채기에 편할 것이다! 


---------------------------------------------------------------------------------



 상속(inheritance)
 
 상속은 객체의 로직을 그대로 물려 받는 또 다른 객체를 만들 수 있는 기능을 의미한다. 

 기존의 로직을 수정하고 변경해서 파생된 새로운 객체를 만들 수 있게 해준다. 

 

 Programmer이라는 생성자를 만들었다.
 그리고 이 생성자의 prototype과 Person의 객체를 연결했더니 
 Programmer 객체도 메소드 introduce를 사용할 수 있게 되었다. 


 부모객체가 있고 

 function Programmer(name){
    this.name = name;

 }
  Programmer.prototype = new Person();
  Programmer.prototype.coding = function(){
    return "hello world";
 }
    즉 프로토타입을 이용해서 이렇게 하면 상속이 가능하다!
 

===================================

 프로토타입 = 자바스크립트의 거대한 개념임 
  (원형)


 객체는 프로퍼티를 가질 수 있는데 prototype이라는 프로퍼티는 그 용도가 약속되어 있는 특수한 프로퍼티다.
 prototype에 저장된 속성들은 생성자를 통해서 객체가 만들어질 때 그 객체에 연결된다. 

부모객체의 prototype 을 받게 되면, 자식객체의 속성에 일어나는 변화가 Prototype Chain 으로 인해
바로 부모에게 영향을 주게 되어 옳바른 작동을 하지 않아서 부모객체를 생성해서 상속받아야 하는군요.
감사합니다^_____^!!!


===================================

 표준내장객체  = 자바스크립트가 기본적으로 가지고 있는 객체
 Standard Built-in Object


 자바스크립트는 아래와 같은 내장 객체를 가지고 있다. 

   Object
   Function
   Array
   String
   Boolean
   Number
   Math (Math.floor 소수점제거, random 랜덤값 0~1)
   Date
   RegExp

 몇개없다! 근데 언어자체의 api 말고 호스트환경이 제공하는 api가 더 있겠지 
 
 내장객체에 메소드를 추가하는 형태로 하이브리드형 객체를 만들수도있다.


- 배열에서 랜덤으로하나 뽑는 메소드- 

 var arr = new Array('seoul','new york','ladarkh','pusan', 'Tsukuba');

 function getRandomValueFromArray(haystack){
     var index = Math.floor(haystack.length*Math.random());
     return haystack[index]; 
 }
 
 console.log(getRandomValueFromArray(arr));

이렇게해도되지만!! 

이렇게 작성해도 된다! 잘못한 것이 아니다. 
하지만 조금 더 세련된 방법은 이 함수를 배열 객체에 포함시키는 것이다. 
그렇게하면 마치 배열에 내장된 메소드인 것처럼 위의 기능을 사용할 수 있다.

 Array.prototype.rand = function(){
    var index = Math.floor(this.length*Math.random()); 		->인자를 안받는다 this가 바로 그객체니깐
    return this[index];
}

var arr = new Array('seoul','new york','ladarkh','pusan', 'Tsukuba');

console.log(arr.rand());

  이렇게 하면 가독성 업!

 즉 프로토타입을 확장하는 것으로 모든객체가 공통적으로 가져야하는 api를 사용자가 직접 정의할수있다는것은 
  멋진 일이다!

------------------------------------

 Object 객체는 객체의 가장 기본적인 형태를 가지고 있는 객체이다.

 오브젝트 의 프로퍼티 그리고 메소드를보여줌 = 많다.

 object.keys()   메소드를 한번살펴보자 = 키값리턴해줌 배열로

 

 object.prototype.toString()  이것두

         객체가 있을때 담고있는게 뭐가있는지보기좋게 나타내줌.

  prototype.toString() 즉 프로토타입이 중요하다 알아둬라.

 
 **즉 여기서 중요한 부분은! 
  
 프로토타입이 중간에있는 즉 prototype.toString() 
 이런거는 모든 객체가 상속받는것이다. 
 a.toString() 뭐이렇게 사용가능 ! 

 즉 오브젝트 프로토타입에 정의를해놓으면 모든객체에서 사용가능




 -------------------------

 데이터타입

  


   1) 원시데이터타입 vs 객체 데이터타입
      기본              참조


 원시데이터타입 = 숫자, 문자열 , 불리언 , 널 , 언디파인드

 
 이게아닌건 객체데이터타입임



  레퍼객체 - 

 var str = 'coding';
console.log(str.length);        // 6
console.log(str.charAt(0));     // "C"

 ?? 원시데이터타입인데 객체처럼 쓰고있네?

 어떤 작업을 하려고 할 때 자바스크립트는 
 임시로 문자열 객체를 만들고 사용이 끝나면 제거하기 때문이다.

 var str = 'coding';
str.prop = 'everybody';
console.log(str.prop);      // undefined

 즉 2번째에서 저장됐다가 사라지겠지.. 레퍼객체니깐 쓰이고없어짐
   

레퍼객체로는 String, Number, Boolean이 있다. 
null과 undefined는 레퍼 객체가 존재하지 않는다.


-----------------------

 참조 

그런데 자연의 산물이 아니라 거대한 약속의 집합인 소프트웨어의 세계에서
당연한 것은 없다. 
이것이 당연하지 않은 이유는 다음 예제를 통해서 좀 더 분명하게 드러난다.

 
var a = {'id':1};
var b = a;
b.id = 2;
console.log(a.id);  // 2
 

????????? 미친뭐야 왜 2가나와..

 다시 말해서 원본을 복제한 것이 아니라 
 원본 파일을 참조(reference)하고 있는 것이다 
  

즉 원시데이터가 아니면 참조를한다 

. 기본 데이터형은 위와 같이 복제 되지만 참조 데이터형은 참조된다.
 모든 객체는 참조 데이터형이다.


var a = 1;
function func(b){
    b = 2;
}
func(a);
console.log(a);  이것과  복제



var a = {'id':1};
function func(b){
    b.id = 2;
}
func(a);
console.log(a.id);  이것의차이 개쉽지?  참조 

 즉 객체데이터타입은 참조를쓴다! 


 중요한건 

 문자열
 숫자      이세개는 원시데이터타입이라는것이다! 객체로쓸수있는건 레퍼객체로 감싸져있어서 
 블리언        

 이걸기억해라 

-------------------------

 재귀함수 

 함수가 자기 자신을 호출하는 것을 재귀함수라고 하는데
 본 예제는 재귀 함수의 예를 보여준다.

 function traverse(target, callback){
    if(target.nodeType === 1){
        //if(target.nodeName === 'A')
        callback(target);
        var c = target.childNodes;
        for(var i=0; i<c.length; i++){
            traverse(c[i], callback);       
        }   
    }
}
traverse(document.getElementById('start'), function(elem){
    console.log(elem);
});
 

 이걸 완벽히 이해하면된다!  